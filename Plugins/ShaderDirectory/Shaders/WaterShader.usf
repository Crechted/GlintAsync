#include "/Engine/Private/Common.ush"
#include "/Engine/Generated/Material.ush"
#include "/Engine/Generated/VertexFactory.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"

struct FWaterMeshPassVSToPS
{
    FVertexFactoryInterpolantsVSToPS FactoryInterpolants;
    float4 Position : SV_POSITION;
    float4 SavedWorldPosition : POSITION1;
    float4 SavedCameraVector : POSITION2;
};

void MainVS(FVertexFactoryInput Input, out FWaterMeshPassVSToPS Output)
{
    ResolvedView = ResolveViewFromVF(Input);
    // get world position
    const FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(Input);
    Output.SavedWorldPosition = VertexFactoryGetWorldPosition(Input, VFIntermediates);
    float3x3 TangentToLocal = VertexFactoryGetTangentToLocal(Input, VFIntermediates);

    FMaterialVertexParameters VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, Output.SavedWorldPosition.xyz,
        TangentToLocal);
    {
        Output.SavedWorldPosition.xyz += GetMaterialWorldPositionOffset(VertexParameters);
    }

    Output.FactoryInterpolants = VertexFactoryGetInterpolantsVSToPS(Input, VFIntermediates, VertexParameters);

    Output.Position = mul(Output.SavedWorldPosition, ResolvedView.TranslatedWorldToClip);
    Output.SavedCameraVector.xyz = LWCToFloat(ResolvedView.WorldCameraOrigin).xyz - Output.SavedWorldPosition.xyz;
}

// need to be deferred output
void MainPS(FWaterMeshPassVSToPS Input
    , out float4 OutTarget0 : SV_Target0
    , out float4 OutTarget1 : SV_Target1
    /*, out float4 OutTarget2 : SV_Target2
    , out float4 OutTarget3 : SV_Target3
    , out float4 OutTarget4 : SV_Target4
    , out float4 OutTarget5 : SV_Target5*/)
{
    FMaterialPixelParameters MaterialParameters = GetMaterialPixelParameters(Input.FactoryInterpolants, Input.Position);

    /*FPixelShaderIn PixelShaderIn = (FPixelShaderIn)0;
    PixelShaderIn.SvPosition = Input.Position;
    PixelShaderIn.bIsFrontFace = true;*/
    FPixelMaterialInputs MaterialInputs;
    CalcPixelMaterialInputs(MaterialParameters, MaterialInputs);

    FGBufferData GBuffer = (FGBufferData)0;

    //GBuffer.PerObjectGBufferData = GetPrimitiveData(MaterialParameters.PrimitiveId).PerObjectGBufferData;

    // final result, now simply use a color
    float3 CameraVector = Input.SavedCameraVector;
    //float3 CameraVector = MaterialFloat3(Input.SavedWorldPosition.xyz);
    float3 WorldNormal = MaterialInputs.Normal;
    float3 BaseColor = MaterialInputs.BaseColor;
    //float3 WorldNormal = EncodeNormal(MaterialParameters.TangentToWorld[2]);
    //float3 WorldNormal = GetMaterialNormal(MaterialParameters, MaterialInputs);
    OutTarget0 = float4(CameraVector, 1.0);
    OutTarget1 = float4(WorldNormal, 1.0);
    /*// normal output
    OutTarget1.rgb = EncodeNormal( MaterialParameters.TangentToWorld[2] );
    //OutTarget1.a = GBuffer.PerObjectGBufferData;
 
    // metallica/specular/roughness buffer output
    OutTarget2 = 0;
    OutTarget2.a = EncodeShadingModelIdAndSelectiveOutputMask(SHADINGMODELID_UNLIT, 0);
 
    // base color output, a channel is for AO
    OutTarget3 = TestColor;
 
    // custom data, set this to red for fun
    OutTarget4 = float4(1, 0, 0, 0);
 
    // shadow factor output, now set it to 1 for test only
    OutTarget5 = 1;*/
}